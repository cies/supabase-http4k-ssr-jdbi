http4k-ssr-with-supabase-auth-and-direct-sql
============================================

Dream stack.

* Supabase — Can't beat their value proposition (auth, object store, scaling, REST, graphQL, subscriptions), and just fallback to Postgres in case it does not fit.
* Kotlin — Beautiful language that anyone with typed OO experience (Java, C#, C++, modern PHP/Ruby/Python) can learn in a weekend. Lift on Java's ecosystem for heavy-lifting. Better culture than Java wrt type-safety.
* http4k — The same architectural model as Rails+Rack (Ruby), or Axum+Tower (Rust) or <many other> use, well implemented in as a bunch of libs Kotlin. Very modular. Very pluggable.
* kotlinx.html — Write HTML templates in Kotlin's DSL syntax, adds type safety where possible.
* Jdbi — Conveniently keep queries in separate SQL files. Does not interfere with SQL code at all (not an ORM or query builder), so 100% "just SQL". (Might want to replace this one day with terpal-sql, once it's a bit more mature.)

The idea is to have Supabase with all it's value ready to be used directly from the browser if needed, while being able to start of with a traditional SSR application.
This because SSR is less expensive to implement than an SPA. SPAs force one to manage state twice and reimplement lots of browser features in JS (back/forward button behaviour, while remembering scroll/form state, etc.).


### Authentication

We use JWTs for authentication. Since this is primarily a server side rendered application, the rotating refresh token scheme is not useful for us.
Therefor we use long-lived JWT access tokens for authentication (a `session_id` does exist, but it is not exposed by the auth service).
These tokens are valid for 100 hours (about half a week) and will be rotated on first use after the first 50 hours of the expiry time have passed.

This requires the following setting in Supabase's `conifg.toml`:

```toml
jwt_expiry = 360000
```


### Authorization

For read queries we define RLS:
* read policies tend to be simpler
* they allow for stronger guarantees against data leaks
* in many cases the autogenerated APIs Supabase offers (REST, GraphQL, realtime)

For modification queries ---for now--- we dont use RLS: all are forbidden.
Maybe someday they can be useful, but for now we hold on this hard rule.

Changes thus all should be made through the application layer, in there you wrap `db.withServiceRole(req) { ... }` around write statements.


### Project goals

* Authentication and authorization the Supabase way, directly with SQL from the backend code, by a `Filter` (http4k concept meaning "for all endpoints that build on top").
* Quick developer cycles.
* Pretty error pages. Useful error pages in development.
* Total control of the db queries being made. 100% PGSQL.
* Full control over the use of db transactions (nesting of transactions is allowed), and no transaction is started automatically per request cycle.
* 12-factor principles (like: configuration by env vars).


### Minimalism

There's a custom task in the Grade file to print the sizes of the dependencies (`depsize-all-configurations`).
I proudly show its output here:

```
Configuration name: "implementationDependenciesMetadata"
Total dependencies size:                                               4.92 Mb

postgresql-42.7.3.jar                                              1,063.78 kb
kotlinx-html-jvm-0.11.0.jar                                          865.22 kb
http4k-core-6.9.2.0.jar                                              836.43 kb
okhttp-4.12.0.jar                                                    771.03 kb
kotlinx-serialization-json-jvm-1.8.1.jar                             270.48 kb
http4k-realtime-core-6.9.2.0.jar                                     198.30 kb
kotlin-stdlib-2.1.20-all.jar                                         188.35 kb
HikariCP-5.1.0.jar                                                   158.05 kb
kotlin-logging-jvm-7.0.7.jar                                         106.46 kb
http4k-format-core-6.9.2.0.jar                                        96.04 kb
slf4j-api-2.0.17.jar                                                  68.27 kb
kotlinx-html-metadata-0.11.0.jar                                      68.15 kb
http4k-config-6.9.2.0.jar                                             59.66 kb
http4k-format-kotlinx-serialization-6.9.2.0.jar                       56.52 kb
kotlinx-serialization-core-metadata-1.8.1.jar                         53.57 kb
kotlinx-serialization-json-metadata-1.8.1.jar                         42.05 kb
okio-metadata-3.6.0-all.jar                                           36.46 kb
http4k-client-okhttp-6.9.2.0.jar                                      28.90 kb
result4k-2.22.3.0.jar                                                 27.39 kb
konform-metadata-0.11.0.jar                                           19.92 kb
slf4j-simple-2.0.17.jar                                               15.35 kb
terpal-runtime-metadata-2.1.0-2.0.0.PL.jar                             6.83 kb
kotlin-stdlib-jdk8-1.8.21.jar                                          0.95 kb
kotlin-stdlib-jdk7-1.8.21.jar                                          0.94 kb
terpal-sql-jdbc-metadata-2.0.0.PL-1.2.0.jar                            0.63 kb
```

5MB for a stack as featureful as this is an amazing feat.


# TODO

* remove the Jackson dependency of moshi (we may be able to use kotchi!)
* fix tests on formparser
* walk through all flows again
* implement some IP + extras logging in
* look into using "arch tests"
* 
